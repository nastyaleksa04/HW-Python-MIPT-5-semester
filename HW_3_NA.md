# HW-Python-MIPT-5-semester
# Урок 3 - git + введение в ООП
## Контрольные вопросы:
- Как расшифровывается __СКВ (VCS)__ и зачем они нужны 
в больших проектах?

СКВ - системы контроля версий. СКВ - это система, которая записывает изменения в файл или набор файлов за период времени и позволяет потом вернуться к предыдущим версиям файлов.
Мы хотим гибко управлять некоторым набором файлом, откатываться до определенных версий в случае необходимости. Можно отменить те или иные изменения файла, откатить его удаление, посмотреть кто что-то поменял. 
СКВ применяются в больших проектах, т.к. такие системы позволяют работать над проектами совместно. СКВ помогают синхронизировать работу всех участников. У каждого из участников есть доступ к актуальной версии проекта, также СКВ предоставляют возможность интегрировать изменения без конфликтов.
Возможность параллельной работы над проектом над разными частями одновременно. СКВ также предоставляют инструменты для разрешения конфликтов, возникающих при одновременной работе над одними и теми же файлами.
- В чем отличия централизованных __СКВ__ от 
децентрализованных?

Система может характеризоваться следующими параметрами: C - consistency (согласованность данных), A - availability (доступность), P - partition tolerance (устойчивость к нарушению связи). 
Централизованные системы - это системы с единственным сервером. Такими системами легко управлять из-за наличия единственного сервера. Но при этом наличие централизованного сервера приводит к возникновению единой точки отказа в виде этого самого сервера. 
Худший сценарий - это уничтожение сервера, что приводит к потери всей информации. Users могут обращаться к серверу и получают из этого централизованного хранилища. Consistency - нет. Часто возникают проблемы конфликтов. Пример: Google documents. 
Децентрализованные системы - это системы, которые имеют удаленные и локальные репозитории.
User выкачает себе весь репозиторий целиком заместо выкачки конкретных интересующих клиента файлов. Если умрет любая копия репозитория, то это не приведет к потере кодовой базы, поскольку она может быть восстановлена с компьютера любого разработчика. Каждая копия является полным бэкапом данных.
Все копии являются равноправным и могут синхронизироваться между собой.
- Что такое __git__ и чем он отличается от __GitHub__?
  
GitHub - это сервис, который предоставляет удаленный репозиторий. Git может существовать без GitHub. Наоборот нет.
Git — это инструмент, который помогает управлять исходным кодом. Он не предоставляет графического интерфейса, а функционирует через командную строку.

- В каких случаях имеет смысл создавать различные 
ветки проекта?

Ветки нужны, чтобы несколько человек могли вести работу над одним и тем же проектом или даже файлом одновременно, при этом не мешая друг другу.
Ветки используются для тестирования новых функций: чтобы не повредить основному проекту, создается новая ветка специально для опробования новых изменений. Если изменения удачные, то это изменения с экспериментальной ветки переносятся на основную, если нет – новая ветка просто удаляется, а проект остается без изменений.
Внутри СКВ можно распараллеливать программу на актуальные, но разные версии. Делаем новую ветку разрабатываем фичу или убираем баг, все проверяем и только потом заливаем в master branch.

- В чем отличия `merge` и `rebase`? В чем 
преимущества и недостатки последнего из них?

Основное предназначение merge состоит в том, чтобы "соединить" изменения двух веток (явное слияние). 
У этого коммита есть одна особенность: два родительских коммита. Один родитель – последний коммит сливаемой ветки, второй – последний коммит целевой ветки.
git merge делает следующие шаги:
1) Проверяет, нет ли конфликтов, т.е. не удалят и не перепишут ли наши изменения какую-либо уже существующую информацию. Если возникает конфликт git merge останавливается, чтобы получить инструкции от пользователя, но этот случай мы рассмотрим ниже. А пока допустим, что конфликтов нет.
   
2) Добавляет все изменения из коммитов 3-5 в индекс ветки main.
   
3) Делает коммит.
   
rebase переносит коммиты текущей ветки на вершину переданной. Переносит коммиты побочной ветки на вершину главной ветки. Коммиты, перенесенные на главную ветку имеют отличные хеш-суммы от коммитов с побочной ветки, но дельты, которые эти коммиты несут в себе, в идеале должны быть одинаковыми.
Преимущества rebase: в нем уже можно сделать fast-forward слияние. История становится более линейной, что облегчает чтение и понимание последовательности изменений.

Недостатки rebase: затруднено отслеживание, откуда пришли изменения.В процессе ребейза могут возникать конфликты, которые нужно будет разрешать по мере перемещения коммитов. Это может быть сложнее, чем при мержах.

- Как расшифровывается __ООП__, в чем заключается идея __объекта__?
  
ООП - объектно-ориентированное программирование. Объект - конкретный представитель класса. Некоторая сущность в цифровом пространстве, обладающая определённым состоянием и поведением, имеющая определенные свойства (поля) и операции над ними (методы).
Все объекты создаются по одному шаблону, могут иметь разные характеристики в пределах конкретного свойства. Объекты одного класса будут обладать одинаковыми методами.

- В чем опасность __переменных класса__?
  
Статические переменные могут создавать глобальное состояние, которое может быть изменено из любого места в программе. Это усложняет отслеживание изменений и может привести к ошибкам, если разные части кода изменяют одно и то же состояние.

Могут снижать уровень инкапсуляции.

При наследовании статические переменные не подчиняются полиморфизму. Это может привести к путанице, когда дочерние классы имеют свои собственные копии статических переменных, которые не связаны с родительским классом.

- Какую роль играет ключевое слово `self`?
  
 self используется для ссылки на текущий экземпляр класса. Так можно обращаться к атрибутам и другим методам этого же экземпляра.
Если в методе есть локальная переменная с таким же именем, как у атрибута экземпляра, использование self дает возможность указать, что речь идет об атрибуте экземпляра.

При вызове метода экземпляра автоматически передается текущий экземпляр в качестве первого аргумента.

self также будет ссылаться на экземпляр дочернего класса, что позволяет использовать методы и атрибуты родительского класса.

self помогает поддерживать инкапсуляцию.

- Как переменная `__dict__` связана с 
остальными __переменными класса__?
Что это говорит нам о природе объектов в __Python__?

__dict__ - словарь, в котором хранится пространство имен класса.

Объекты в Python являются динамическими. Каждый объект имеет свою собственную структуру данных, что позволяет хранить связанные данные вместе.Поскольку все атрибуты хранятся в виде словаря, это упрощает манипуляции с ними. 

- В чем заключается основная идея __инкапсуляции__?
  
Сложность реализации компонента спрятана под интерфейсом.


## Задания:
1) Создайте класс для хранения комплексных чисел с инициализатором.
class Storage:
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

2) Реализуйте методы, позволяющие представлять комплексное число в 
экспоненциальной форме.
import math
class Storage:
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def expon(self):
        r = (self.real**2+self.imaginary**2)**0.5
        phi = math.atan2(self.imaginary, self.real)
        print("Экспоненциальная форма: ", r , "* exp(i *", phi, ")")


3) Добавьте функции, позволяющие складывать, вычитать, 
умножать и делить два комплексных числа, результатом работы 
которых будет новое комплексное число (именно функции, не методы, 
перегружать операторы тоже не надо).
import math
class Storage:
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def expon(self):
        r = (self.real**2+self.imaginary**2)**0.5
        phi = math.atan2(self.imaginary, self.real)
        print("Экспоненциальная форма: ", r , "* exp(i *", phi, ")")
        return r, phi

def conj(a):
    return Storage(a.real, -a.imaginary)
def summation(a, b):
    new_real = a.real + b.real
    new_imaginary = a.imaginary + b.imaginary
    return Storage(new_real, new_imaginary)
def subtraction(a, b):
    new_real = a.real - b.real
    new_imaginary = a.imaginary - b.imaginary
    return Storage(new_real, new_imaginary)
def multiplication(a, b):
    new_real = a.real*b.real - a.imaginary*b.imaginary
    new_imaginary = a.real*b.imaginary + b.real*a.imaginary
    return Storage(new_real, new_imaginary)
def division(a, b):
    denominator = b.real**2 + b.imaginary**2
    new_num = multiplication(a, b.conj())
    return Storage(new_num.real / denominator, new_num.imaginary / denominator)
