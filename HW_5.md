- В чем основная идея __полиморфизма__? Как он реализуется в Python.

Ответ: Основная идея полиморфизма в том, чтобы дать единый интерфейс для самых разных реализаций. В Python используется динамическая типизация. Работает так называемая "утиная типизация". Python проверяет есть ли у соответствующего объекта нужные методы, если они есть, то он их вызывает, не глядя на то,что они делают. т.е. в какой-то мере полиморфизм в Python уже реализован. В питоне реализация уходит в соответствующий метод.
```python
Например, функция len(). Мы хотим найти эту фукнцию от структуры данных, которую мы реализовали сами. Функция len() вызывает соответствующий ей внутренний метод a.__len__(). Поэтому эта функция будет работать с любым объектом, у которого есть такой метод.
Функцию len() можно переписать в виде:
def len(x):    
    return x.__len__() 

```


- Зачем переопределять метод `__radd__()` наравне с 
`__add__()`?

Ответ: 
Рассмотрим оператор z = x + y, его можно заменить на метод:
```python
z = x.__add__(y) и эквивалентный метод z = y.__radd__(x).
```
Может оказаться так, что левый операнд не может работать с правым, но правый с левым может. Если окажется так, то питон проверит может ли правый прибавлять к себе левый. Например, если мы заводим свою струтуру данных и хотим складывать ее с числом. И пользователь прописал число + моя структура данных. Мы не будем лезть в исходный код питона и переписывать, поэтому в свою струткуру данных допишем. Чтобы от перестановки слагаемых сумма не менялась.


- Как можно описать взаимоотношения 
__родительского__ и __дочернего__ классов?

Ответ: дочерний класс наследует методы родительского. Желательно (для правильной проектировки классов), чтобы выполнялся критерий Барбары-Лисков: наследующий класс должен дополнять, а не замещать поведение базового класса. 
С точки зрения кода, потомок расширяет предков. А с точки зрения логики, потомок уточняет предка. Родительский класс может иметь атрибуты, которые будут доступны и в дочерних классах, если они не являются приватными. Дочерний класс может добавлять свои собственные свойства, специфичные для него.




- Для чего используется ключевое 
слово `super()`?

Ответ: Унаследованные методы можно переопределить, а можно дополнить (добавить что-то к унаследованной реализации).
super() - обращение к унаследованной реализации, т.е. вместо супер подставиться тот предок, из которого мы наследуем эту реализацию. подстановка класса предка по C3 MRO.

- Какую роль играет порядок классов __предков__
при __множественном наследовании__?

Ответ: Если при множественном наследовании у двух разных предков есть один и тот же метод, то возникает проблема от кого брать этот метод - вопрос приоритетов. 
В старых версиях питона использовался DFS для определения порядка обхода предков:
class C(A, B) - если предок указан первым,то ему отдавался больший приоритет. Предка перебирались слева направо обходом в глубину. Проблема в том, что в таком обходе методы должны были бы браться из B, а берутся из Object.

Object(2) \
|     ____               |  \
A(1)  B(3)  \
  \ ___  /   \
     C    

В новых версиях питона обход C3 MRO. По возможности идет по ветке, которая была указана первой.

- Зачем нужна __обработка исключений__? В каких 
случаях ее использование некорректно?

Ответ: 
Обработка исключений - это работа с ошибками. Обработка исключений обеспечивает возможность продолжать выполнение программы даже в случае возникновения ошибок. Исключения позволяют более четко указать на проблему, что дает возможность реагировать на различные типы ошибок (например, ошибка ввода данных).
Исключения часто предоставляют стек вызовов и другие диагностические данные, которые помогают быстро выяснить причину ошибки. 
 Исключения не должны использоваться как способ управления нормальным потоком выполнения программы. Они предназначены для обработки ошибок, а не для реализации логики, например, применения условий "если" или "выбор".Не стоит просто ловить все исключения и ничего не делать с ними (например, использование конструкции try...catch без обработки ошибок). Если можно избежать исключений с помощью проверки условий, то лучше использовать такие подходы. Использование исключений в ситуациях, когда стоит позволить программе завершаться естественным образом (например, пользователь закрыл приложение), может привести к непредсказуемым результатам.
- Зачем в блоке `try` использовать раздел
`finally`?

Ответ: finally отрабатывает всегда, есть ситуации, когда независимо от того произошло ли исключение или нет, нужно что-то сделать. Пример: работа с файлами. Мы открыли файл и начали с ним работать. Файл нужно закрыть независимо от того, произошла или не произошла ошибка. Его в любом случае нужно закрыть.  

- Что нужно сделать, чтобы реализовать 
свое собственное __исключение__?

Для реализации собственного исключения надо создать новый класс исключения. Можно наследовать от встроенного класса Exception. Дальше можно определить метод __init__(), в котором можно передать параметры. Можно также переопределить метод __str__(). Пример:
```python
class MyCustomError(Exception):
    def __init__(self, message):
        super().__init__(message)  
        self.message = message  
    
   
    def __str__(self):
        return f"MyCustomError: {self.message}"

# Пример использования
def do_something(value):
    if value < 0:
        
        raise MyCustomError("Значение не может быть отрицательным!")
    else:
        print(f"Ввели значение: {value}")

# Тестирование
try:
    do_something(-10)
except MyCustomError as e:
    print(e)  


```
- Чем итератор отличается от генератора?
  
Ответ: В отличие от итератора, генератор не обязан быть привязанным к какому-то объекту. Итератор дополняет существующий объект. Генератор не бежит по чему-то готовому, он создает значения налету. 


- В чем минусы декорирования функций?
  
Ответ: Декораторы могут сделать код менее понятным. Ошибка может указывать на декорированную функцию, а не на оригинальную, это затрудняет выявление проблемы. Использование декораторов может оказать влияние на производительность, особенно если они выполняют дополнительные операции или вызывают дополнительные функции.
Могут быть конфликты между различными декораторами, если они изменяют одно и то же поведение функции. Иногда декораторы могут сделать код менее гибким, так как трудно менять поведение декорированной функции без изменения декоратора.
